<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TUIJS Demo</title>
</head>
<body>
    <script>
        /**
 * Takes an HTML template literal, parses it with the DOM parser, then extracts the element with querySelectorAll.
 */
        function elmCleaner(templateLit) {
            try {
                let parser = new DOMParser();
                let elmBody = parser.parseFromString(templateLit, 'text/html');
                let elms = elmBody.body.querySelectorAll("*");
                return elms[0];
            } catch (er) {
                console.error(er);
                throw new Error(er);
            }
        }

        /**
         * Parses template literal with 'template' tag
         */
        function parseTemplate(templateLit) {
            try {
                let parser = new DOMParser();
                let doc = parser.parseFromString(templateLit, 'text/html');
                let template = doc.querySelector('template');
                if (!template) {
                    throw new Error('No template tag found in the provided string.');
                }
                return template.content;
            } catch (er) {
                console.error(er);
                throw new Error(er);
            }
        }

        class TuiElement extends HTMLElement {
            constructor() {
                super();
                this.attributeCount = 0;
                this.renderRequested = false;
                this.rendered = false;
                // The attribute length must be stored in a separate variable so that it can be manipulated.
                this.attributeLength = this.attributes.length;
            }

            /**
             * Extension of HTMLElement method 'connectedCallback'.
             */
            connectedCallback() {
                /**
                 * If render requested is equal to true, or the attribute length is observed to be 0
                 * call the render method and mark the rendered status as true
                 */
                if (this.renderRequested === true || this.attributeLength === 0) {
                    this.render();
                    this.rendered = true;
                }
            }

            /**
             * Extension of HTMLElement method 'attributeChangedCallback'.
             * Observes element changes
             * @param {*} name 
             * @param {*} oldValue 
             * @param {*} newValue 
             * @returns 
             */
            attributeChangedCallback(name, oldValue, newValue) {
                if (oldValue !== newValue) {
                    this[name] = newValue; // Set the new value
                    /**
                     * If the rendered status is true
                     * Re-render the element, ignoring non-rerender attributes
                     */
                    if (this.rendered === true) {
                        // If the shadow root is used, render on the shadow root context and not the this context
                        if (this.shadowRoot) {
                            this.shadowRoot.replaceChildren(); // This clears the element in prep for rerender - DO NOT REMOVE
                            this.render();
                            return;
                        }
                        this.replaceChildren(); // This clears the element in prep for rerender - DO NOT REMOVE
                        this.render();
                        return;
                    }
                    /**
                     * If the element has not already been rendered
                     * Add 1 to the attribute count.
                     * 
                     * If the attribute count is equal to or greater than the length,
                     * mark 'renderRequested' as true
                     */
                    this.attributeCount++;
                    if (this.attributeCount >= this.attributeLength) {
                        this.renderRequested = true;
                        return;
                    }
                }
            }

            /**
             * This method is used to move HTML elements placed inside the custom element tags to another element withing the custom element.
             * 
             * Example; if you have an un-ordered list 'ul' as a child element of the custom element,
             * you can move list item 'li' tags withing the 'ul'
             * 
             * If more than one tag type needs to be moved, this method can be run twice by the child class.
             * @param {Object} newParent - The target new parent element for the tags to be moved to.
             * @param {String} tag - The tag type that will be moved from the parent to the newParent.
             * @returns {void}
             */
            moveTaggedChildren(newParent, tag) {
                let elms = this.querySelectorAll(`${tag}`);
                let fragment = document.createDocumentFragment();
                elms.forEach(elm => {
                    fragment.appendChild(elm); // Append to fragment
                });
                newParent.appendChild(fragment); // Append all at once to reduce reflows
                return;
            }

            /**
             * Moves text nodes of the parent element to a specified child element
             * @param {Object} childElement - The target child element where the text will be moved
             * @returns {void}
             */
            moveTextToChild(childElement) {
                let directText = ""; // Initialize a variable to store the direct text
                // Iterate over child nodes of the parent element
                for (const node of this.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        directText += node.textContent.trim() + " "; // Append the trimmed text content to the directText variable
                        this.removeChild(node); // Remove the text node from the parent element
                    }
                }
                directText = directText.trim();// Trim any trailing whitespace
                childElement.innerText = directText;
                return;
            }

            /**
             * This method deletes all child elements from the custom element, except for the one specified. 
             * 
             * For example, if you have an un-ordered list 'ul' as a child element of the custom element,
             * and you only want to allow 'li' elements as children to the custom element,
             * you can use this method to delete other child elements.
             * 
             * THIS WILL BE UPDATED IN THE FUTURE TO ALLOW MULTIPLE TAG TYPES TO BE KEPT,
             * LIKELY USING AN ARRAY AS THE METHOD ARGUMENT.
             */
            deleteChildrenExceptTagged(tag) {
                const children = Array.from(this.children);
                for (let i = 0; i < children.length; i++) {
                    if (children[i].tagName.toLowerCase() !== tag.toLowerCase()) {
                        children[i].remove();
                    }
                }
                return;
            }
        }

        let elm = elmCleaner(`<color-box color-1="red" color-2="green"></color-box>`);
        document.body.appendChild(elm);
        class ColorBox extends TuiElement {
            constructor() {
                super();
                this.color1 = this.getAttribute('color-1');
                this.color2 = this.getAttribute('color-2');
            }
            static get observedAttributes() {
                return ['color-1', 'color-2'];
            }
            render() {
                let elmTemplate = /*HTML*/`
                    <template>
                        <div style="height: 64px;width: 64px;background-color: ${this.color1}">
                            <p style="color: black">Color Box<p>
                        <div>
                    </template>
                `;
                this.appendChild(parseTemplate(elmTemplate));
                this.addEventListener('click', () => this.handleButtonClick());
                return;
            }
            handleButtonClick() {
                const div = this.querySelector('div');
                div.style.backgroundColor = this.color2;
                return;
            }
        }
        customElements.define('color-box', ColorBox);

    </script>
</body>
</html>